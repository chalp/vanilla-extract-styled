# vanilla-extract-styled

A small wrapper/utility for using `@vanilla-extract/recipes` and styled components in your project.

This package provides a convenient `styled` API on top of vanilla-extract recipes and is intended to be published as a library (supports both ESM and CommonJS). The README describes installation, usage examples, and packaging/SSR recommendations.


## Installation

We recommend using pnpm (or npm/yarn):

```bash
pnpm add @chalp/vanilla-extract-styled
# or
npm install @chalp/vanilla-extract-styled
```

### Peer dependencies

The package requires the following peer dependencies to be present in the project (they are not bundled):

- react (>=17)
- react-dom (>=17)
- @vanilla-extract/css
- @vanilla-extract/recipes

Install them in your project if they are not already present:

```bash
pnpm add react react-dom @vanilla-extract/css @vanilla-extract/recipes -w
```

## Usage

The key function: `styled(elemType, ...recipes)`.

- `elemType` — a React element/component: a string tag (`'div'`, `'button'`, etc.) or a React component (functional or class).
- `...recipes` — any number of arguments, each of which can be:
  - a string — an already prepared `className` that will be appended to the resulting `className`;
  - a `RuntimeFn<VariantGroups>` function from `@vanilla-extract/recipes` (a recipe function). This function will be called at render time with an options object collected from the component's props.

The return value is a React component. Its props are:
- all props of the original `elemType` (for example, for `'button'` — standard button attributes);
- plus automatically inferred variant props that correspond to the passed recipe functions;
- optional `className?: string`.

How `styled` calls a recipe function

The implementation takes each recipe function and calls it like this:
- it inspects `recipeFn.classNames.variants` (the keys of variant groups);
- from the component props, it picks only those keys that are present in `recipeFn.classNames.variants`;
- it constructs an options object and passes it to `recipeFn(options)`;
- the result (a string of classes) is added to an array of `classes`.

The final `className` is the list of all classes (in the order recipes were passed), plus the `className` from component props (if provided), joined with spaces.

Important: prop forwarding

Current implementation: all remaining props (including variant props) are forwarded to the created element via spread. This means:
- if `elemType` is a string DOM tag (`'div'`, `'button'`), non-standard attributes (for example, `variant`) will end up in the DOM and trigger React/validator warnings. We recommend:
  - using a prefix for custom prop names (for example, `$variant`) when working with DOM elements;
  - or using your own component as `elemType` that accepts and strips custom props before forwarding them to the DOM.

About refs

The function returns a simple functional component without `forwardRef`. If you need ref forwarding, wrap the result in `React.forwardRef` manually.

Examples

1) Simple example: a string class

```tsx
import styled from '@chalp/vanilla-extract-styled';

const Box = styled('div', 'my-base-class');

// In render
// <Box className="local" /> => element with class="my-base-class local"
```

2) Recipe function (TypeScript)

Assume you have a recipe generated by `@vanilla-extract/recipes`:

```ts
import { recipe } from '@vanilla-extract/recipes';

export const buttonRecipe = recipe({
  base: 'btn',
  variants: {
    variant: {
      primary: 'btn--primary',
      ghost: 'btn--ghost',
    },
    size: {
      small: 'btn--sm',
      medium: 'btn--md',
    },
  },
});
```

Using `styled`:

```ts
import styled from '@chalp/vanilla-extract-styled';
import { buttonRecipe } from './button.css';

const Button = styled('button', buttonRecipe);

// In JSX
// <Button variant="primary" size="small">OK</Button>
// styled will call buttonRecipe({ variant: 'primary', size: 'small' })
// and add the resulting className to the element
```

3) Multiple recipes and string classes

```ts
const Card = styled('div', baseCardRecipe, shadowRecipe, 'ux-card');

// Order matters: classes will be in the order [baseCard, shadow, 'ux-card', props.className]
```

4) Custom React component

```tsx
const Link = ({ href, className, children, ...rest }) => (
  <a href={href} className={className} {...rest}>{children}</a>
);

const StyledLink = styled(Link, linkRecipe);

// <StyledLink href="/" active>Home</StyledLink>
// All props are passed to Link, and linkRecipe will be called with appropriate variant props
```

Types (short)

The returned component is typed as:

ComponentType< ComponentPropsWithoutRef<E> & VariantPropsFromMerged<T> & { className?: string } >

This means TypeScript will try to infer variant props from the provided recipe functions (`VariantPropsFromMerged<T>`).

TypeScript example (detailed)

Below is a more detailed example of types and real usage. Types are taken from `src/styled.ts` and shown here to illustrate how types are inferred in user code.

```ts
// Type imports (assumes @vanilla-extract/recipes is installed)
import type { ComponentType, ElementType, ComponentPropsWithoutRef } from 'react';
import type { RuntimeFn, RecipeVariants } from '@vanilla-extract/recipes';

// Helper utilities (as in src/styled.ts)
type Resolve<T> = { [Key in keyof T]: T[Key]; } & {};
type BooleanMap<T> = T extends 'true' | 'false' ? boolean : T;
type RecipeStyleRule = any; // ComplexStyleRule | string — simplified for README
type VariantDefinitions = Record<string, RecipeStyleRule>;
type VariantGroups = Record<string, VariantDefinitions>;

type VariantSelection<Variants extends VariantGroups> = {
  [VariantGroup in keyof Variants]?: BooleanMap<keyof Variants[VariantGroup]> | undefined;
};

// RecipeOrClass — either a runtime recipe function or a className string
type RecipeOrClass = RuntimeFn<VariantGroups> | string;

type EmptyObject = NonNullable<unknown>;

// Main type: merges variant prop types from all provided recipe functions
type VariantPropsFromMerged<T extends readonly RecipeOrClass[]> = T[number] extends infer V
  ? V extends RuntimeFn<VariantGroups>
    ? RecipeVariants<V>
    : EmptyObject
  : EmptyObject;

// Return component type
type StyledReturn<
  E extends ElementType,
  T extends readonly RecipeOrClass[],
> = ComponentType<ComponentPropsWithoutRef<E> & VariantPropsFromMerged<T> & { className?: string }>;
```

Usage example (in your code):

```tsx
import React from 'react';
import styled from '@chalp/vanilla-extract-styled';
import { recipe } from '@vanilla-extract/recipes';

// Example recipe (typical @vanilla-extract/recipes code)
export const buttonRecipe = recipe({
  base: 'btn',
  variants: {
    variant: {
      primary: 'btn--primary',
      ghost: 'btn--ghost',
    },
    size: {
      small: 'btn--sm',
      medium: 'btn--md',
    },
  },
});

// 1) styled with an HTML tag
const Button = styled('button', buttonRecipe);

// TypeScript will infer props as:
// ComponentPropsWithoutRef<'button'> & VariantPropsFromMerged<[typeof buttonRecipe]> & { className?: string }

// Usage in JSX:
// <Button variant="primary" size="small">OK</Button>

// 2) styled with a custom React component
type LinkProps = { href: string; children?: React.ReactNode };
const Link = ({ href, className, children, ...rest }: LinkProps & { className?: string }) => (
  <a href={href} className={className} {...rest}>{children}</a>
);

const linkRecipe = recipe({
  base: 'link',
  variants: {
    active: { true: 'link--active' },
  },
});

const StyledLink = styled(Link, linkRecipe);

// Prop types: LinkProps & VariantPropsFromMerged<[typeof linkRecipe]> & { className?: string }
// Usage: <StyledLink href="/" active>Home</StyledLink>
```

Notes

- The first argument to `styled` is either a string tag (`'div'`, `'button'`) or a React component.
- You can pass any number of arguments afterward: strings (pre-made class names) and/or recipe functions (`RuntimeFn<VariantGroups>`).
- `VariantPropsFromMerged<T>` merges the variant types (`RecipeVariants`) from all provided recipe functions.
- If you pass recipe functions that share variant group names, the resulting props will be merged accordingly (the behavior is defined by `RecipeVariants` types from `@vanilla-extract/recipes`).

Helpers

The package also exports simple color utilities:

- darken(value: string, amount: number, colorSpace?: 'srgb' | 'oklab') => string
  - Darkens the color `value` by `amount` (0..1). The returned string is a CSS `color-mix(...)` expression that can be used in recipes.
  - Example: `darken('#ffcc00', 0.15)` → "color-mix(in srgb, #ffcc00 15%, black)".

- lighten(value: string, amount: number, colorSpace?: 'srgb' | 'oklab') => string
  - Lightens the color `value` by `amount`.
  - Example: `lighten('#002244', 0.1)`.

- opacify(value: string, amount: number, colorSpace?: 'srgb' | 'oklab') => string
  - Applies or combines opacity — returns a CSS `color-mix(...)` with `transparent`.
  - Example: `opacify('#000000', 0.5)`.

Examples of using helpers in recipes:

```ts
import { recipe } from '@vanilla-extract/recipes';
import { darken, opacify } from './helpers';

export const alertRecipe = recipe({
  base: 'alert',
  variants: {
    tone: {
      info: { background: opacify('#0af', 0.1) },
      warn: { background: darken('#ffcc00', 0.05) },
    },
  },
});
```

Recommendations

- Remember to prefix variant props if you forward them to the DOM (for example, `$variant`) or use a component as `elemType` that filters out DOM-incompatible props.
- `styled` does not automatically forward refs — wrap the result with `React.forwardRef` if you need a ref.

Contributing and development

- Follow the project rules (ESLint, Airbnb styles).
- Run linting and build before creating a PR:

```bash
pnpm --filter @chalp/vanilla-extract-styled lint
pnpm --filter @chalp/vanilla-extract-styled build
# add tests/vitest as needed
```

License

MIT
